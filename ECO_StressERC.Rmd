---
title: "Perceived Stress Predicts Emotion Regulation Choice: The Role of Cognitive Resources, Depressive Symptoms, and Beliefs"
author: "Mengzhe Wei, Tammy English"
date: "`r Sys.Date()`"
output:
  html_document:
    theme: journal
    toc: yes
    toc_float:
      collapsed: true
---

# ECO Stress and ER Choice Analysis
Notes: Started 17 Sep 2024 by Mengzhe Wei to run analysis looking at ER Decisions and strategy selection based on stress. 
Within person (level 1): stress level in EMA
Between person (level 2): Perceived stress scale
Moderators: CES-D, dweck.sum (implicit beliefs about emotion), MCI groups (young, CN, MCI), cogflu.uc (cognitive fluid score uncorrected)
Outcome variables: 
1. Whether participant chose to influence their emotions; 
2. the frequency of strategy use

```{r setup, echo=FALSE, eval=TRUE, warning=FALSE, message=FALSE}
# Set up packages and upload data. 
rm(list=ls());
options(warnPartialMatchDollar=TRUE);   # safety option
library(lme4); library(knitr); library(RColorBrewer); library (kableExtra);library(correlation); library(tidyverse); library(psych); library(data.table);library(lmerTest);library(performance);library(car);library(gridExtra);library(glmmTMB)
#Set up packages and upload data.
rm(list=ls());
library(boxr);
box_auth();
wustl.box <- TRUE;
#Packages
library(lme4); library(knitr); library(RColorBrewer); library (kableExtra);library(correlation); library(tidyverse);library(boxr); library(psych)
#Load the dataset
data_files <- box_ls('278065273295')
file_name <- paste0("ECO_ESM_person-level.csv")
file_id <- box_search(file_name)
ESM <- box_read(file_id) %>% as.data.frame()
file_name <- paste0("ECO_baseline.csv")
file_id <- box_search(file_name)
survey <- box_read(file_id) %>% as.data.frame()
```

## Data Quality Check

### Dataset Cleaning
Given that many participants also indicated that they did try to influence their emotions despite answering "no" to emotion regulation since the last survey, we decided to include those who indicated that the most recent time that they influence their emotions were 0-1.5 hours before the prompt, if it wasn't captured by the last survey. Since each interval is 2 hours, 0-1.5 should be able to capture the ER between two prompts. I also made three different variables capturing just "at the prompt" to make within-person analysis more accurate. 
```{r dataset, eval=FALSE, echo=FALSE, warning=FALSE, cache=TRUE, message=FALSE}
# Found participants with no PSS score
missing_PSS <- survey %>%
  filter(is.na(perceived_stress_sum))%>%
  select(PID)
#Frequency of influencing their emotions
emotions_influence_summary <- ESM %>%
  group_by(PID) %>%
  summarize(yes_count = sum(esm_influence_emo == 1, na.rm = TRUE),
            yes_percentage = yes_count/63)
hist(emotions_influence_summary$yes_percentage, breaks = 20, border = "black",main = "ESM ER Percentage", xlab = "Percentage of time selecting YES for influencing emotions", ylab = "# of Participants")
#Given that many participants also indicated that they did try to influence their emotions despite answering "no" to emotion regulation since the last survey, we decided to include those who indicated that the most recent time that they influence their emotions were 0-1.5 hours before the prompt, if it wasn't captured by the last survey. Since each interval is 2 hours, 0-1.5 should be able to capture the ER between two prompts.

# Clean up the full dataset for within person
ESM_test <- ESM
ESM_test$day <- (ESM_test$Prompt - 1) %/% 7 + 1
# Determine the day of survey
ESM_test$ER_yes <- NA  # Set NA as default for non-completed surveys
# Loop through each PID
for (pid in unique(ESM_test$PID)) {
  # Subset data for the current PID
  subset_data <- ESM_test[ESM_test$PID == pid, ]
  # Initialize variables to track the last completed survey
  last_completed_time <- NULL
  last_completed_day <- NULL
  # Loop through each row for the current PID
  for (i in 1:nrow(subset_data)) {
    # Check if survey is completed
    if (subset_data$completed[i] == 1) {
      # Check if Start_time is missing (NA)
      if (is.na(subset_data$Start_time[i])) {
        subset_data$ER_yes[i] <- NA  # Assign ER_yes = 0 if Start_time is missing
        next  # Skip to the next row
      }
      # Get current day and time
      current_day <- subset_data$day[i]
      current_time <- as.POSIXct(subset_data$Start_time[i], format = "%H:%M:%S")
      # If it's the first completed survey
      if (is.null(last_completed_time)) {
        if (!is.na(subset_data$esm_influence_emo[i]) && subset_data$esm_influence_emo[i] == 1 || 
            (!is.na(subset_data$esm_time_manage[i]) && subset_data$esm_time_manage[i] %in% 1:4)) {
          subset_data$ER_yes[i] <- 1
        } else {
          subset_data$ER_yes[i] <- 0
        }
        # Update last completed survey info
        last_completed_time <- current_time
        last_completed_day <- current_day
      # If it's not the first completed survey
      } else {
        # Check if it's a new day
        if (current_day != last_completed_day) {
          if (!is.na(subset_data$esm_influence_emo[i]) && subset_data$esm_influence_emo[i] == 1 || 
              (!is.na(subset_data$esm_time_manage[i]) && subset_data$esm_time_manage[i] %in% 1:4)) {
            subset_data$ER_yes[i] <- 1
          } else {
            subset_data$ER_yes[i] <- 0
          }
        } else {
          # Calculate time gap in minutes
          time_gap <- as.numeric(difftime(current_time, last_completed_time, units = "mins"))
          # Check based on time gap and esm_time_manage
          if (!is.na(subset_data$esm_time_manage[i]) && subset_data$esm_time_manage[i] == 1) {
            subset_data$ER_yes[i] <- 1
          } else if (!is.na(subset_data$esm_time_manage[i]) && subset_data$esm_time_manage[i] == 2 && time_gap >= 30) {
            subset_data$ER_yes[i] <- 1
          } else if (!is.na(subset_data$esm_time_manage[i]) && subset_data$esm_time_manage[i] == 3 && time_gap >= 60) {
            subset_data$ER_yes[i] <- 1
          } else if (!is.na(subset_data$esm_time_manage[i]) && subset_data$esm_time_manage[i] == 4 && time_gap >= 90) {
            subset_data$ER_yes[i] <- 1
          } else {
            subset_data$ER_yes[i] <- 0
          }
        }
        # Update last completed time and day
        last_completed_time <- current_time
        last_completed_day <- current_day
      }
    } else {
      # If not completed, assign NA
      subset_data$ER_yes[i] <- NA
    }
  }
  # Update the main dataset with the new ER_yes
  ESM_test[ESM_test$PID == pid, "ER_yes"] <- subset_data$ER_yes
}
#Create strategy selection variables
ESM_test$distr_yes <- ifelse(is.na(ESM_test$ER_yes) | (is.na(ESM_test$esm_howinfluence) & is.na(ESM_test$er_othermethods_distraction)), 
                             NA, 
                             ifelse(
                               ESM_test$ER_yes == 1 & (!is.na(ESM_test$esm_howinfluence) & ESM_test$esm_howinfluence == 10 | 
                                                         !is.na(ESM_test$er_othermethods_distraction) & ESM_test$er_othermethods_distraction == 1), 
                               1, 0))
ESM_test$min_yes <- ifelse(is.na(ESM_test$ER_yes) | (is.na(ESM_test$esm_howinfluence) & is.na(ESM_test$er_othermethods_minimize)), 
                           NA, 
                           ifelse(ESM_test$ER_yes == 1 & 
                                    (!is.na(ESM_test$esm_howinfluence) & ESM_test$esm_howinfluence == 12 | 
                                       !is.na(ESM_test$er_othermethods_minimize) & ESM_test$er_othermethods_minimize == 1), 
                                  1, 0))
ESM_test$reap_yes <- ifelse(is.na(ESM_test$ER_yes) | (is.na(ESM_test$esm_howinfluence) & is.na(ESM_test$er_othermethods_posreapp)), 
                             NA, 
                            ifelse(ESM_test$ER_yes == 1 & 
                            (!is.na(ESM_test$esm_howinfluence) & ESM_test$esm_howinfluence == 11 | 
                             !is.na(ESM_test$er_othermethods_posreapp) & ESM_test$er_othermethods_posreapp == 1), 
                            1, 0))
#Create a new strategy selection that only includes "at the time of the prompt" for more accurate within person response
ESM_test$distr_yes_prompt <- ifelse(is.na(ESM_test$esm_time_manage) | (is.na(ESM_test$esm_howinfluence) & is.na(ESM_test$er_othermethods_distraction)), 
                             NA, 
                             ifelse(
                               ESM_test$esm_time_manage == 1 & (!is.na(ESM_test$esm_howinfluence) & ESM_test$esm_howinfluence == 10 | 
                                                         !is.na(ESM_test$er_othermethods_distraction) & ESM_test$er_othermethods_distraction == 1), 
                               1, 0))
ESM_test$min_yes_prompt <- ifelse(is.na(ESM_test$esm_time_manage) | (is.na(ESM_test$esm_howinfluence) & is.na(ESM_test$er_othermethods_minimize)), 
                           NA, 
                           ifelse(ESM_test$esm_time_manage == 1 & 
                                    (!is.na(ESM_test$esm_howinfluence) & ESM_test$esm_howinfluence == 12 | 
                                       !is.na(ESM_test$er_othermethods_minimize) & ESM_test$er_othermethods_minimize == 1), 
                                  1, 0))
ESM_test$reap_yes_prompt <- ifelse(is.na(ESM_test$esm_time_manage) | (is.na(ESM_test$esm_howinfluence) & is.na(ESM_test$er_othermethods_posreapp)), 
                             NA, 
                            ifelse(ESM_test$esm_time_manage == 1 & 
                            (!is.na(ESM_test$esm_howinfluence) & ESM_test$esm_howinfluence == 11 | 
                             !is.na(ESM_test$er_othermethods_posreapp) & ESM_test$er_othermethods_posreapp == 1), 
                            1, 0))
# Create NA composite
ESM_test$negemotions <- rowMeans(ESM_test[,c("esm_stressed","esm_lonely","esm_angry","esm_nervous","esm_fearful","esm_sad","esm_disgusted","esm_sluggish","esm_bored","esm_isolated")],na.rm=TRUE)
ESM_test_lag <- ESM_test %>%
  group_by(PID, day) %>%
  mutate (esm_stressed_lag = lag(esm_stressed, 1),
    negemotions_lag = lag(negemotions, 1),
    control_lag = lag(situation_control,1),
  ) %>%
  ungroup()
ESM_clean <- ESM_test_lag[, c("PID", "day", "Group", "completed", "esm_time_manage","esm_stressed","esm_lonely","esm_angry","esm_nervous","esm_fearful","esm_sad","esm_disgusted","esm_sluggish","esm_bored","esm_isolated", "negemotions","esm_stressed_lag", "negemotions_lag","situation_control","control_lag", "esm_wanted_change", "ER_yes", "distr_yes", "min_yes", "reap_yes", "distr_yes_prompt", "min_yes_prompt","reap_yes_prompt","sd.cogflu.uc", "perceived_stress_sum", "CES_D_sum", "dweck.sum", "Gender", "Age", "Race2_1", "Race2_2", "Race2_3", "Race2_4", "Race2_5", "Race2_6", "Race2_7")]
write.csv(ESM_clean, "C:/Users/Emotion/Documents/GIT-MW/ECO/ESM_clean.csv")
```

```{r center, eval=TRUE, echo=FALSE, warning=FALSE, cache=TRUE, message=FALSE}
# Read in dataset
ESM_clean<-fread("ESM_clean.csv")
survey <- fread("ECO_baseline.csv")
data <-ESM_clean %>%
  group_by(PID) %>%
  mutate (Group_code = case_when(Group == 0 ~ -1,  Group == 1 ~ 0, Group == 2 ~ 1),
          Group = factor(Group_code, levels = -1:1, labels = c("YA","CN","MCI")),
          stress_pm = mean(esm_stressed,na.rm=TRUE),
          ER_yes_pm = sum(ER_yes,na.rm = TRUE)/ sum(completed==1,na.rm = TRUE),
          distr_pm = ifelse(sum(ER_yes,na.rm = TRUE) > 0, sum(distr_yes,na.rm = TRUE) / sum(ER_yes,na.rm = TRUE), 0),
          min_pm = ifelse(sum(ER_yes,na.rm = TRUE) > 0, sum(min_yes,na.rm = TRUE) / sum(ER_yes,na.rm = TRUE), 0),
          reap_pm = ifelse(sum(ER_yes,na.rm = TRUE) > 0, sum(reap_yes,na.rm = TRUE) / sum(ER_yes,na.rm = TRUE), 0),
          ER_yes_prompt = ifelse(is.na(esm_time_manage), NA, ifelse(esm_time_manage == 1, 1, 0)),
          ER_yes_prompt_pm = sum(esm_time_manage==1,na.rm = TRUE)/sum(completed==1,na.rm = TRUE),
          distr_prompt_pm = ifelse(sum(esm_time_manage==1,na.rm = TRUE) > 0, sum(distr_yes_prompt,na.rm = TRUE) / sum(esm_time_manage==1,na.rm = TRUE), 0),
          min_prompt_pm = ifelse(sum(esm_time_manage==1,na.rm = TRUE) > 0, sum(min_yes_prompt,na.rm = TRUE) / sum(esm_time_manage==1,na.rm = TRUE), 0),
          reap_prompt_pm = ifelse(sum(esm_time_manage==1,na.rm = TRUE) > 0, sum(reap_yes_prompt,na.rm = TRUE) / sum(esm_time_manage==1,na.rm = TRUE), 0)) %>% 
  ungroup()%>%
  mutate(
    stress_gmc = scale(esm_stressed, center = T, scale = F),
    stress_w = esm_stressed - stress_pm,
    stress_b = stress_gmc - stress_w,
    stress_pm_gmc = scale(stress_pm, center = T, scale = F),
    PSS_gmc = scale(perceived_stress_sum, center = T, scale = F),
    CESD_gmc = scale(CES_D_sum, center = T, scale = F),
    IBES_gmc = scale(dweck.sum, center = T, scale = F),
    NIHCB_gmc = scale(sd.cogflu.uc, center = T, scale = F)) %>%
  as.data.frame()
data_b <- data %>%
  group_by(PID) %>%
  summarise(
    Group_code=first(Group_code),
    Group = first(Group),  # Assuming all entries of a single group per PID are the same
    completed_sum = sum(completed==1,na.rm = TRUE),
    ER_yes_sum = sum(ER_yes,na.rm = TRUE),
    ER_yes_prompt_sum = sum(ER_yes_prompt,na.rm=TRUE),
    perceived_stress_sum = first(perceived_stress_sum),
    CES_D_sum = first(CES_D_sum),
    dweck_sum = first(dweck.sum),
    sd_cogflu_uc = first(sd.cogflu.uc),
    stress_pm = first(stress_pm),
    stress_pm_gmc = first(stress_pm_gmc),
    ER_yes_pm = first(ER_yes_pm),
    distr_pm = first(distr_pm),
    min_pm = first(min_pm),
    reap_pm = first(reap_pm),
    ER_yes_prompt_pm = first(ER_yes_prompt_pm),
    distr_prompt_pm = first(distr_prompt_pm),
    min_prompt_pm = first(min_prompt_pm),
    reap_prompt_pm = first(reap_prompt_pm),
    PSS_gmc = first(PSS_gmc),
    CESD_gmc = first(CESD_gmc),
    IBES_gmc = first(IBES_gmc),
    NIHCB_gmc = first(NIHCB_gmc)
  ) %>%
  ungroup() %>%
  as.data.frame()
sum(data_b$ER_yes_sum)
sum(data_b$ER_yes_prompt_sum)
```

### Check internal consistency
```{r Internal consistency, eval=TRUE, echo=TRUE, cache=TRUE, warning=FALSE, message=FALSE}
#Check internal consistency
CESD <- select(survey,CES_D_1:CES_D_20)
omega(CESD) #alpha=0.93, omega=0.95
PSS <- select(survey,c(perceived_stress_1:perceived_stress_3,perceived_stress_4r,perceived_stress_5r,perceived_stress_6,perceived_stress_7r, perceived_stress_8r,perceived_stress_9,perceived_stress_10))
omega(PSS) #alpha=0.89, omega=0.9
belief <- select(survey,Emotion_Beliefs_1r,Emotion_Beliefs_2,Emotion_Beliefs_3, Emotion_Beliefs_4r)
omega(belief) #alpha=0.75, omega = 0.79
```

### Data distribution and Descriptive Stats
```{r distribution,fig.width=10, fig.height=6, eval=TRUE, echo=TRUE, cache=TRUE,warning=FALSE, message=TRUE}
layout(matrix(1:16, 4,4, byrow=TRUE)); 
par(mar = c(2, 2, 2, 1), mgp = c(1.1, 0.2, 0), tcl = -0.3)
#Check distribution of all data; loop through histogram
variables <- c("completed_sum","ER_yes_sum","ER_yes_prompt_sum","perceived_stress_sum","CES_D_sum", "dweck_sum","sd_cogflu_uc","stress_pm", "ER_yes_pm","distr_pm", "min_pm","reap_pm","ER_yes_prompt_pm","distr_prompt_pm","min_prompt_pm","reap_prompt_pm")
for (vid in 1:length(variables)) { #vid<-3
  hist(data_b[[variables[vid]]], breaks = 20, border = "black",main = variables[vid], xlab = variables[vid], ylab = "Count")
}
# boxplot to check the relationship between cognitive fluid score and cognitive impairment
boxplot(data_b$sd_cogflu_uc~data_b$Group, main="NIHCB score by MCI group", xlab= "Group", ylab="Score", 
        col = c("lightblue", "lightgreen", "lightcoral"),
        border = "black",
        notch = TRUE,
        varwidth = TRUE)
par(mfrow = c(1, 1))
# Overall stats including centered variables
describe(data_b)
length(which(data_b$CES_D_sum>=16))
# 67 participants met the cutoff for significant depressive symptomatology
```

### Demographics
```{r Demo, eval=TRUE, echo=TRUE,cache=TRUE, warning=FALSE, message=FALSE}
#Demo table
demo.sum <- data %>% distinct(PID, .keep_all=TRUE) %>%
  select(PID, Group, Race2_1, Race2_2, Race2_3, Race2_4, Race2_5, Race2_6, Race2_7, 
         Gender, Age)
#Group, 0=young adult, 1=CN older adults, 2=MCI older adult
demo.sum %>%
  count(Group)
#Race
demo.sum %>%
  summarise(
    African_American_Black = mean(Race2_1), 
    American_Indian_Alaskan_Native = mean(Race2_2),
    Asian_Asian_American_Pacific_Islander = mean(Race2_3),
    Middle_Eastern_Arab_American = mean(Race2_4),
    Caucasian_European_American = mean(Race2_5),
    Hispanic_Latino = mean(Race2_6),
    Other = mean(Race2_7)
  )
#Age
demo.sum %>%
  summarise(
    mean_age=mean(Age),
    sd_age=sd(Age),
    min_age=min(Age),
    max_age=max(Age)
  )
#Age group by cognitive group
demo.sum %>%
  group_by(Group) %>%
  summarise(
    mean_age=mean(Age),
    sd_age=sd(Age),
    min_age=min(Age),
    max_age=max(Age)
  )
#Gender
demo.sum %>%
  mutate (Gender = factor(Gender, levels = 0:2, labels = c("male","female","other"))) %>%
  count(Gender)
```

### intraclass correlations of EMA items
```{r EMA cor, echo=TRUE,eval=TRUE,cache=TRUE,warning=F, message=F}
fit_logit <- glmer(ER_yes ~ 1 + (1 | PID), data = data, family = binomial(link = "logit"))
model_performance(fit_logit) 
#ICC = .463,54% variance is within person
fit_logit <- glmer(distr_yes ~ 1 + (1 | PID), data = data, family = binomial(link = "logit"))
model_performance(fit_logit) 
#ICC = 0.464,54% variance is within person
fit_logit <- glmer(min_yes ~ 1 + (1 | PID), data = data, family = binomial(link = "logit"))
model_performance(fit_logit) 
#ICC = 0.435
fit_logit <- glmer(reap_yes ~ 1 + (1 | PID), data = data, family = binomial(link = "logit"))
model_performance(fit_logit) 
#ICC = 0.48
fit_logit <- glmer(ER_yes_prompt ~ 1 + (1 | PID), data = data, family = binomial(link = "logit"))
model_performance(fit_logit) 
#ICC = 0.434
fit_logit <- glmer(distr_yes_prompt ~ 1 + (1 | PID), data = data, family = binomial(link = "logit"))
model_performance(fit_logit) 
#ICC = 0.510 
fit_logit <- glmer(min_yes_prompt ~ 1 + (1 | PID), data = data, family = binomial(link = "logit"))
model_performance(fit_logit) 
#ICC = 0.588 
fit_logit <- glmer(reap_yes_prompt ~ 1 + (1 | PID), data = data, family = binomial(link = "logit"))
model_performance(fit_logit) 
#ICC = 0.671 
fit0 <- glmer(esm_stressed ~ 1 + (1 | PID), data = data)
model_performance(fit0) 
#ICC = 0.408, 59% variance is within person
```


## Between-Person Analysis

### Correlations
```{r cor, echo=TRUE,eval=TRUE,warning=F, cache=TRUE, message=F}
data$PID<-as.numeric(data$PID)
data$Group_code <- as.factor(data$Group_code)
stats<-statsBy(select(data,c("PID","Group","esm_stressed","ER_yes","distr_yes","min_yes","reap_yes","distr_yes_prompt","min_yes_prompt","reap_yes_prompt","sd.cogflu.uc","perceived_stress_sum","CES_D_sum","dweck.sum")),group="PID")
#between person correlations
stats$rbg #Between-Person Correlation for Raw Scores
stats$pbg #Between-Person Correlation for Person-Mean Centered Scores
#within person correlations
stats$rwg #Within-Person Correlation for Raw Scores
stats$pwg #Within-Person Correlation for Person-Mean Centered Scores

within_person_correlations <- stats$rwg

# Extract the variable names
var_names <- colnames(within_person_correlations)

# Initialize an empty matrix to store p-values
p_value_matrix <- matrix(NA, nrow = length(var_names), ncol = length(var_names))
rownames(p_value_matrix) <- var_names
colnames(p_value_matrix) <- var_names

# Loop through variable pairs and calculate p-values using cor.test
for (i in 1:length(var_names)) {
  for (j in 1:length(var_names)) {
    if (i != j) {  # Avoid calculating for the same variable
      # Handle missing values using na.omit
      valid_data <- na.omit(within_person_correlations[, c(i, j)])
      
      # Only run cor.test if enough valid data is available
      if (nrow(valid_data) > 2) {  # cor.test requires at least 3 observations
        cor_test_result <- cor.test(valid_data[, 1], valid_data[, 2])
        p_value_matrix[i, j] <- cor_test_result$p.value
      } else {
        p_value_matrix[i, j] <- NA  # Not enough data to calculate p-value
      }
    }
  }
}

# View the p-value matrix
print(p_value_matrix)

library(Hmisc)

# Select the numeric variables you want to correlate
cor_data <- select(data_b, c("ER_yes_pm","distr_pm", "min_pm", "reap_pm", "stress_pm", "CES_D_sum", "Group_code"))
# Compute correlation matrix with significance levels
cor_matrix <- rcorr(as.matrix(cor_data))
# View the correlation matrix
cor_matrix$r   # This is the correlation matrix
# View the p-values for the correlations
cor_matrix$P   # This shows the p-values for significance
```

### Association between overall ER use & PSS
Higher PSS score is associated with higher percentage of ER use and distraction use.
In the models for main effects, I included moderators to control for their effect. Multicollinearity issue was assessed through VIF, doesn't seem to have a problem here.
```{r PSS ER, echo=TRUE,eval=TRUE,cache=TRUE, warning=F, message=F}
# stress predicting whether or not ER strategy was selected
ER <- lm(ER_yes_pm ~ PSS_gmc+CESD_gmc+IBES_gmc+NIHCB_gmc+Group, data=data_b)
summary(ER) #higher PSS score is associated with higher percentage of using emotion regulation, effect holds when other variables are controlled for
vif(ER)
# stress predicting ER strategy preference
#distraction
distr <- lm(distr_pm~ PSS_gmc+CESD_gmc+IBES_gmc+NIHCB_gmc+Group, data=data_b)
summary(distr) #higher PSS score is associated with higher percentage of using distraction, effect holds when other variables are controlled for
# b = 0.005994     
vif(distr)
#minimizing
min <- lm(min_pm~ PSS_gmc+CESD_gmc+IBES_gmc+NIHCB_gmc+Group, data=data_b)
summary(min) #N.S.  
vif(min)
#reappraisal
reap <- lm(reap_pm~ PSS_gmc+CESD_gmc+IBES_gmc+NIHCB_gmc+Group, data=data_b)
summary(reap) #N.S.
vif(reap)
```

### Moderation analysis: ER use & PSS
Malleability belief weakens the association between stress and ER use. 
```{r PSS ER mod, fig.width=10, fig.height=8, echo=TRUE,eval=TRUE,warning=F,cache=TRUE,  message=F}
# stress predicting whether or not ER strategy was selected
# CESD: sd=12.04
ER <- lm(ER_yes_pm ~ PSS_gmc*CESD_gmc+IBES_gmc+NIHCB_gmc+Group, data=data_b)
summary(ER)
#N.S.
# IBES sd = 3.47
ER <- lm(ER_yes_pm ~ PSS_gmc*IBES_gmc+CESD_gmc+NIHCB_gmc+Group, data=data_b)
summary(ER) #p=0.06
describe(data_b$IBES_gmc) #for standard deviations
ef <- effects::effect(term="PSS_gmc*IBES_gmc", xlevels= list(IBES_gmc=c(-3.47, 3.47)), mod=ER)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$IBES_gmc<-as.factor(efdata$IBES_gmc)
ggplot(efdata, aes(x=PSS_gmc, y=fit, color=IBES_gmc,group=IBES_gmc)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=IBES_gmc),alpha=0.3) + 
    labs(x= "PSS", y="ER use", color="IBES", fill="IBES") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 1, by=0.2), limits=c(0,1)) +
    scale_x_continuous(breaks = seq(-12, 20, by=4), limits=c(-12,20))
#IBES significantly moderates
#NIHCB sd = 15.87
ER <- lm(ER_yes_pm ~ PSS_gmc*NIHCB_gmc+CESD_gmc+IBES_gmc+Group, data=data_b)
summary(ER)
#N.S.
#MCI
ER <- lm(ER_yes_pm ~ PSS_gmc*Group+CESD_gmc+IBES_gmc+NIHCB_gmc, data=data_b)
summary(ER)
#N.S.
```

### Moderation analysis: strategy preference & PSS
```{r PSS ER mod strategy, fig.width=10, fig.height=8, echo=TRUE,eval=TRUE,warning=F, cache=TRUE, message=F}
# stress predicting ER strategy preference
# CESD
#distraction
distr <- lm(distr_pm~ PSS_gmc*CESD_gmc+IBES_gmc+NIHCB_gmc+Group, data=data_b)
summary(distr)
#N.S.
#minimizing
min <- lm(min_pm~ PSS_gmc*CESD_gmc+IBES_gmc+NIHCB_gmc+Group, data=data_b)
summary(min)
#N.S.
#reappraisal
reap <- lm(reap_pm~ PSS_gmc*CESD_gmc+IBES_gmc+NIHCB_gmc+Group, data=data_b)
summary(reap) 
#N.S.
# IBES
# distraction
distr <- lm(distr_pm~ PSS_gmc*IBES_gmc+CESD_gmc+NIHCB_gmc+Group, data=data_b)
summary(distr)
ef <- effects::effect(term="PSS_gmc*IBES_gmc", xlevels= list(IBES_gmc=c(-3.47, 3.47)), mod=distr)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$IBES_gmc<-as.factor(efdata$IBES_gmc)
g1<-ggplot(efdata, aes(x=PSS_gmc, y=fit, color=IBES_gmc,group=IBES_gmc)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=IBES_gmc),alpha=0.3) + 
    labs(x= "PSS", y="Distraction Use", color="IBES", fill="IBES") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.6, by=0.1), limits=c(0,0.6)) +
    scale_x_continuous(breaks = seq(-12, 20, by=4), limits=c(-12,20))
#minimizing
min <- lm(min_pm~ PSS_gmc*IBES_gmc+CESD_gmc+NIHCB_gmc+Group, data=data_b)
summary(min)
ef <- effects::effect(term="PSS_gmc*IBES_gmc", xlevels= list(IBES_gmc=c(-3.47, 3.47)), mod=min)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$IBES_gmc<-as.factor(efdata$IBES_gmc)
g2<-ggplot(efdata, aes(x=PSS_gmc, y=fit, color=IBES_gmc,group=IBES_gmc)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=IBES_gmc),alpha=0.3) + 
    labs(x= "PSS", y="Minimizing Use", color="IBES", fill="IBES") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.6, by=0.1), limits=c(-0.02, 0.6)) +
    scale_x_continuous(breaks = seq(-12, 20, by=4), limits=c(-12,20))
#reappraisal
reap <- lm(reap_pm~ PSS_gmc*IBES_gmc+CESD_gmc+NIHCB_gmc+Group, data=data_b)
summary(reap) 
#N.S.
# NIHCB
# distraction
distr <- lm(distr_pm~ PSS_gmc*NIHCB_gmc+CESD_gmc+IBES_gmc+Group, data=data_b)
summary(distr)
#N.S.
#minimizing
min <- lm(min_pm~ PSS_gmc*NIHCB_gmc+CESD_gmc+IBES_gmc+Group, data=data_b)
summary(min)
# N.S.
#reappraisal
reap <- lm(reap_pm~ PSS_gmc*NIHCB_gmc+CESD_gmc+IBES_gmc+Group, data=data_b)
summary(reap) 
#N.S.
# MCI
# distraction
distr <- lm(distr_pm~ PSS_gmc*Group+CESD_gmc+NIHCB_gmc+IBES_gmc, data=data_b)
summary(distr)
#N.S.
#minimizing
min <- lm(min_pm~ PSS_gmc*Group+CESD_gmc+NIHCB_gmc+IBES_gmc, data=data_b)
summary(min)
#N.S.
#reappraisal
reap <- lm(reap_pm~ PSS_gmc*Group+CESD_gmc+NIHCB_gmc+IBES_gmc, data=data_b)
summary(reap) 
#N.S.
grid.arrange(g1, g2, ncol=2)
```

### Association between overall ER use & mean stress score in ESM
Higher ESM stress is associated with higher overall ER use, and all three strategy use. Among the specific strategies, distraction is the most influenced by stress, followed by minimizing and reappraisal.
```{r ESMstress ER, echo=FALSE,eval=FALSE,warning=F, cache=TRUE, message=F}
# stress predicting whether or not ER strategy was selected
ER <- lm(ER_yes_pm ~ stress_pm_gmc+CESD_gmc+IBES_gmc+NIHCB_gmc+Group, data=data_b)
summary(ER) #higher ESM stress is associated with higher percentage of using emotion regulation, effect holds when other variables are controlled for
# b = 0.0932690  
# stress predicting ER strategy preference
#distraction
distr <- lm(distr_pm~ stress_pm_gmc+CESD_gmc+IBES_gmc+NIHCB_gmc+Group, data=data_b)
summary(distr) #higher ESM stress is associated with higher percentage of using distraction, effect holds when other variables are controlled for
# b = 0.0487570      
#minimizing
min <- lm(min_pm~ stress_pm_gmc+CESD_gmc+IBES_gmc+NIHCB_gmc+Group, data=data_b)
summary(min) #higher ESM stress is associated with higher percentage of using minimizing, effect holds when other variables are controlled for
# b = 0.031064       
#reappraisal
reap <- lm(reap_pm~ stress_pm_gmc+CESD_gmc+IBES_gmc+NIHCB_gmc+Group, data=data_b)
summary(reap) #higher PSS score is associated with higher percentage of using reappraisal, effect holds when other variables are controlled for
# b = 0.0302119      
```

### Moderation analysis: ER use & ESM stress
```{r ESMstress ER mod, fig.width=10, fig.height=8, echo=TRUE,eval=TRUE,warning=F,cache=TRUE,  message=F}
# stress predicting whether or not overall ER strategy was used
# CESD
ER <- lm(ER_yes_pm ~ stress_pm_gmc*CESD_gmc+IBES_gmc+NIHCB_gmc+Group, data=data_b)
summary(ER)
# N.S.
# IBES
ER <- lm(ER_yes_pm ~ stress_pm_gmc*IBES_gmc+CESD_gmc+NIHCB_gmc+Group, data=data_b)
summary(ER)
#N.S.
#NIHCB
ER <- lm(ER_yes_pm ~ stress_pm_gmc*NIHCB_gmc+CESD_gmc+IBES_gmc+Group, data=data_b)
summary(ER)
# N.S.
#NIHCB significantly moderate
#MCI
ER <- lm(ER_yes_pm ~ stress_pm_gmc*Group+CESD_gmc+IBES_gmc+NIHCB_gmc, data=data_b)
summary(ER)
#N.S.
```

### Moderation analysis: Strategy preference & ESM stress
Depressive symptoms weaken the association between stress and distraction use.
Depressive symptoms weaken the association between stress and reappraisal use.
Fluid cognition score weakens the association between stress and all three strategy use (Note, for distraction p=0.08). People with less cognitive resources use distraction a lot more when encountering stress. (the only big increase in strategy selection frequency for people with more cognitive resources is distraction)
Stress is more positively associated with distraction in CN adults
Stress is more positively associated with reappraisal use in CN adults. (p=0.07)
```{r ESMstress ER mod strategy, fig.width=10, fig.height=8, echo=TRUE,eval=TRUE,warning=F, cache=TRUE, message=F}
# stress predicting ER strategy preference
# CESD
#distraction
distr <- lm(distr_pm~ stress_pm_gmc*CESD_gmc+IBES_gmc+NIHCB_gmc+Group, data=data_b)
summary(distr)
ef <- effects::effect(term="stress_pm_gmc*CESD_gmc", xlevels= list(CESD_gmc=c(-12.04, 12.04)), mod=distr)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$CESD_gmc<-as.factor(efdata$CESD_gmc)
g1<-ggplot(efdata, aes(x=stress_pm_gmc, y=fit, color=CESD_gmc,group=CESD_gmc)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=CESD_gmc),alpha=0.3) + 
    labs(x= "ESM stress", y="Distraction Use", color="CESD_gmc", fill="CESD_gmc") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.6, by=0.1), limits=c(0,0.6)) +
    scale_x_continuous(breaks = seq(-2, 4, by=1), limits=c(-2,4))
#minimizing
min <- lm(min_pm~ stress_pm_gmc*CESD_gmc+IBES_gmc+NIHCB_gmc+Group, data=data_b)
summary(min)
#N.S.
#reappraisal
reap <- lm(reap_pm~ stress_pm_gmc*CESD_gmc+IBES_gmc+NIHCB_gmc+Group, data=data_b)
summary(reap) 
ef <- effects::effect(term="stress_pm_gmc*CESD_gmc", xlevels= list(CESD_gmc=c(-12.04, 12.04)), mod=reap)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$CESD_gmc<-as.factor(efdata$CESD_gmc)
g2<-ggplot(efdata, aes(x=stress_pm_gmc, y=fit, color=CESD_gmc,group=CESD_gmc)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=CESD_gmc),alpha=0.3) + 
    labs(x= "ESM stress", y="Reappraisal Use", color="CESD_gmc", fill="CESD_gmc") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.6, by=0.1), limits=c(0, 0.6)) +
    scale_x_continuous(breaks = seq(-2, 4, by=1), limits=c(-2,4))
# IBES
# distraction
distr <- lm(distr_pm~ stress_pm_gmc*IBES_gmc+CESD_gmc+NIHCB_gmc+Group, data=data_b)
summary(distr)
#N.S.
#minimizing
min <- lm(min_pm~ stress_pm_gmc*IBES_gmc+CESD_gmc+NIHCB_gmc+Group, data=data_b)
summary(min)
#N.S.
#reappraisal
reap <- lm(reap_pm~ stress_pm_gmc*IBES_gmc+CESD_gmc+NIHCB_gmc+Group, data=data_b)
summary(reap) 
#N.S.
# NIHCB
# distraction
distr <- lm(distr_pm~ stress_pm_gmc*NIHCB_gmc+CESD_gmc+IBES_gmc+Group, data=data_b)
summary(distr)
ef <- effects::effect(term="stress_pm_gmc*NIHCB_gmc", xlevels= list(NIHCB_gmc=c(-15.87, 15.87)), mod=distr)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$NIHCB_gmc<-as.factor(efdata$NIHCB_gmc)
g3<-ggplot(efdata, aes(x=stress_pm_gmc, y=fit, color=NIHCB_gmc,group=NIHCB_gmc)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=NIHCB_gmc),alpha=0.3) + 
    labs(x= "ESM stress", y="Distraction Use", color="NIHCB_gmc", fill="NIHCB_gmc") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.6, by=0.1), limits=c(0,0.6)) +
    scale_x_continuous(breaks = seq(-2, 4, by=1), limits=c(-2,4))
#minimizing
min <- lm(min_pm~ stress_pm_gmc*NIHCB_gmc+CESD_gmc+IBES_gmc+Group, data=data_b)
summary(min)
ef <- effects::effect(term="stress_pm_gmc*NIHCB_gmc", xlevels= list(NIHCB_gmc=c(-15.87, 15.87)), mod=min)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$NIHCB_gmc<-as.factor(efdata$NIHCB_gmc)
g4<-ggplot(efdata, aes(x=stress_pm_gmc, y=fit, color=NIHCB_gmc,group=NIHCB_gmc)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=NIHCB_gmc),alpha=0.3) + 
    labs(x= "ESM stress", y="Minimizing Use", color="NIHCB_gmc", fill="NIHCB_gmc") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.6, by=0.1), limits=c(-0.02,0.6)) +
    scale_x_continuous(breaks = seq(-2, 4, by=1), limits=c(-2,4))
#reappraisal
reap <- lm(reap_pm~ stress_pm_gmc*NIHCB_gmc+CESD_gmc+IBES_gmc+Group, data=data_b)
summary(reap) 
ef <- effects::effect(term="stress_pm_gmc*NIHCB_gmc", xlevels= list(NIHCB_gmc=c(-15.87, 15.87)), mod=reap)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$NIHCB_gmc<-as.factor(efdata$NIHCB_gmc)
g5<-ggplot(efdata, aes(x=stress_pm_gmc, y=fit, color=NIHCB_gmc,group=NIHCB_gmc)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=NIHCB_gmc),alpha=0.3) + 
    labs(x= "ESM stress", y="Reappraisal Use", color="NIHCB_gmc", fill="NIHCB_gmc") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.6, by=0.1), limits=c(0,0.6)) +
    scale_x_continuous(breaks = seq(-2, 4, by=1), limits=c(-2,4))
# MCI
# distraction
distr <- lm(distr_pm~ stress_pm_gmc*Group+CESD_gmc+NIHCB_gmc+IBES_gmc, data=data_b)
summary(distr)
ef <- effects::effect(term="stress_pm_gmc*Group", mod=distr)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$Group<-as.factor(efdata$Group)
g6<-ggplot(efdata, aes(x=stress_pm_gmc, y=fit, color=Group,group=Group)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=Group),alpha=0.3) + 
    labs(x= "ESM stress", y="Distraction Use", color="Group", fill="Group") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.6, by=0.1), limits=c(0,0.6)) +
    scale_x_continuous(breaks = seq(-2, 4, by=1), limits=c(-2,4))
#minimizing
min <- lm(min_pm~ stress_pm_gmc*Group+CESD_gmc+NIHCB_gmc+IBES_gmc, data=data_b)
summary(min)
#N.S.
#reappraisal
reap <- lm(reap_pm~ stress_pm_gmc*Group+CESD_gmc+NIHCB_gmc+IBES_gmc, data=data_b)
summary(reap) 
ef <- effects::effect(term="stress_pm_gmc*Group", mod=reap)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$Group<-as.factor(efdata$Group)
g7<-ggplot(efdata, aes(x=stress_pm_gmc, y=fit, color=Group,group=Group)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=Group),alpha=0.3) + 
    labs(x= "ESM stress", y="Reappraisal Use", color="Group", fill="Group") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.6, by=0.1), limits=c(0,0.6)) +
    scale_x_continuous(breaks = seq(-2, 4, by=1), limits=c(-2,4))
grid.arrange(g1, g2, g3, g4, g5, g6, g7, ncol=3)
```

## Multilevel Modeling

### Stress predicting overall ER use & each strategy use
Higher momentary within-person stress is associated with using more ER.
Higher between-person stress is associated with using more ER.
At the time of the prompt, higher momentary within-person stress is associated with more ER.
```{r withinER,echo=TRUE,eval=TRUE,warning=F, cache=TRUE, message=F}
ER <- glmer(ER_yes ~ stress_w + stress_b + CESD_gmc + IBES_gmc + NIHCB_gmc + Group + 
                        (1 | PID), 
                        family = binomial(link = "logit"),
                        data = data)

summary(ER)
ER <- glmer(ER_yes ~ stress_w + stress_b + CESD_gmc + Group + 
                        (1 + stress_w | PID), 
                        family = binomial(link = "logit"),
                        data = data)
summary(ER)
#Just whether ER is use *at the time of the prompt*
ER <- glmer(ER_yes_prompt ~ stress_w + stress_b + CESD_gmc + IBES_gmc + NIHCB_gmc + Group + 
                        (1 | PID), 
                        family = binomial(link = "logit"),
                        data = data)

summary(ER)
```

### Moderation analysis: overall ER use
Higher momentary within-person stress is associated with using all three strategies more (same finding at the time of the prompt).
Higher between-person stress is associated with using all three strategies more (same finding at the time of the prompt).
I am not sure why I didn't actually run the moderation analysis for overall er use...
```{r withinER mod,echo=TRUE,eval=TRUE,warning=F, cache=TRUE, message=F}
distr <- glmer(distr_yes ~ stress_w + stress_b + CESD_gmc + IBES_gmc + NIHCB_gmc + Group + (1 | PID), 
               family = binomial(link = "logit"),
               data = data,
               control = glmerControl(optimizer = "bobyqa"))
summary(distr)
distr <- glmer(distr_yes ~ stress_w + stress_b + CESD_gmc + Group + (1 + stress_w|PID), 
               family = binomial(link = "logit"),
               data = data,
               control = glmerControl(optimizer = "bobyqa"))
summary(distr)
#w: b=0.194915; b: b=0.667780   
distr <- glmer(distr_yes_prompt ~ stress_w + stress_b + CESD_gmc + IBES_gmc + NIHCB_gmc + Group + (1 | PID), 
               family = binomial(link = "logit"),
               data = data,
               control = glmerControl(optimizer = "bobyqa"))
summary(distr)
#w: b=0.29874    ; b: b=0.55748        
min <- glmer(min_yes ~ stress_w + stress_b + CESD_gmc + IBES_gmc + NIHCB_gmc + Group + (1 | PID), 
             family = binomial(link = "logit"),
             data = data,
             control = glmerControl(optimizer = "bobyqa"))
summary(min)
min <- glmer(min_yes ~ stress_w + stress_b + CESD_gmc + Group +(1 + stress_w|PID), 
             family = binomial(link = "logit"),
             data = data,
             control = glmerControl(optimizer = "bobyqa"))
summary(min)
#w: b = 0.12584; b: b = 0.52575    
min <- glmer(min_yes_prompt ~ stress_w + stress_b + CESD_gmc + IBES_gmc + NIHCB_gmc + Group + (1 | PID), 
             family = binomial(link = "logit"),
             data = data,
             control = glmerControl(optimizer = "bobyqa"))
summary(min)
#w: b=0.30049; b: b = 0.46522    
reap <- glmer(reap_yes ~ stress_w + stress_b + CESD_gmc + IBES_gmc + NIHCB_gmc + Group + (1 | PID), 
              family = binomial(link = "logit"),
              data = data,
              control = glmerControl(optimizer = "bobyqa"))
summary(reap)
#w: b=0.170498; b: b=0.541553   
reap <- glmer(reap_yes ~ stress_w + stress_b + CESD_gmc + Group + (1 + stress_w|PID), 
              family = binomial(link = "logit"),
              data = data,
              control = glmerControl(optimizer = "bobyqa"))
summary(reap)
reap <- glmer(reap_yes_prompt ~ stress_w + stress_b + CESD_gmc + IBES_gmc + NIHCB_gmc + Group + 
                (1 | PID), 
              family = binomial(link = "logit"),
              data = data,
              control = glmerControl(optimizer = "bobyqa"))
summary(reap)
#w: b=0.269128; b: b=0.550578   
```

### Moderation analysis: specific ER use
```{r withinER strategy mod,echo=TRUE,eval=TRUE,fig.width=10, fig.height=8, warning=F, cache=TRUE, message=F}
#CESD
distr <- glmer(distr_yes ~ stress_w*CESD_gmc + stress_b*CESD_gmc + (1 + stress_w | PID), 
               family = binomial(link = "logit"),
               data = data)
summary(distr)
ef <- effects::effect(term="CESD_gmc:stress_b", xlevels= list(CESD_gmc=c(-12.04, 12.04)), mod=distr)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$CESD_gmc<-as.factor(efdata$CESD_gmc)
g1<-ggplot(efdata, aes(x=stress_b, y=fit, color=CESD_gmc,group=CESD_gmc)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=CESD_gmc),alpha=0.3) + 
    labs(x= "stress_b", y="Distraction Use", color="CESD_gmc", fill="CESD_gmc") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.8, by=0.1), limits=c(0,0.8)) +
    scale_x_continuous(breaks = seq(-1.5, 4, by=1), limits=c(-1.5,4))
distr <- glmer(distr_yes_prompt ~ stress_w*CESD_gmc + stress_b*CESD_gmc +(1 | PID), 
                        family = binomial(link = "logit"),
                        data = data)

summary(distr)
min <- glmer(min_yes ~ stress_w*CESD_gmc + stress_b*CESD_gmc +(1 + stress_w | PID), 
                        family = binomial(link = "logit"),
                        data = data)
summary(min)
min <- glmer(min_yes_prompt ~ stress_w*CESD_gmc + stress_b*CESD_gmc+(1 | PID), 
                        family = binomial(link = "logit"),
                        data = data,
              control = glmerControl(optimizer = "bobyqa"))
summary(min)
ef <- effects::effect(term="stress_w:CESD_gmc", xlevels= list(CESD_gmc=c(-12.04, 12.04)), mod=min)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$CESD_gmc<-as.factor(efdata$CESD_gmc)
g2<-ggplot(efdata, aes(x=stress_w, y=fit, color=CESD_gmc,group=CESD_gmc)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=CESD_gmc),alpha=0.3) + 
    labs(x= "stress_w", y="Minimizing Use, Prompt", color="CESD_gmc", fill="CESD_gmc") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.08, by=0.02), limits=c(0,0.08)) +
    scale_x_continuous(breaks = seq(-5.5, 6, by=2), limits=c(-5.5,6))
reap <- glmer(reap_yes ~ stress_w*CESD_gmc + stress_b*CESD_gmc + 
                        (1 + stress_w| PID), 
                        family = binomial(link = "logit"),
                        data = data)
summary(reap)
ef <- effects::effect(term="CESD_gmc:stress_b", xlevels= list(CESD_gmc=c(-12.04, 12.04)), mod=reap)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$CESD_gmc<-as.factor(efdata$CESD_gmc)
g3<-ggplot(efdata, aes(x=stress_b, y=fit, color=CESD_gmc,group=CESD_gmc)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=CESD_gmc),alpha=0.3) + 
    labs(x= "stress_b", y="Reappraisal Use", color="CESD_gmc", fill="CESD_gmc") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.8, by=0.1), limits=c(0,0.8)) +
    scale_x_continuous(breaks = seq(-1.5, 4, by=1), limits=c(-1.5,4))
reap <- glmer(reap_yes_prompt ~ stress_w*CESD_gmc + stress_b*CESD_gmc + (1 | PID), 
                        family = binomial(link = "logit"),
                        data = data)
summary(reap)
ef <- effects::effect(term="CESD_gmc:stress_b", xlevels= list(CESD_gmc=c(-12.04, 12.04)), mod=reap)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$CESD_gmc<-as.factor(efdata$CESD_gmc)
g4<-ggplot(efdata, aes(x=stress_b, y=fit, color=CESD_gmc,group=CESD_gmc)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=CESD_gmc),alpha=0.3) + 
    labs(x= "stress_b", y="Reappraisal Use, prompt", color="CESD_gmc", fill="CESD_gmc") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.2, by=0.05), limits=c(-0.015, 0.2)) +
    scale_x_continuous(breaks = seq(-1.5, 4, by=1), limits=c(-1.5,4))
#IBES #N.S.
distr <- glmer(distr_yes ~ stress_w*IBES_gmc + stress_b*IBES_gmc + (1 | PID), 
                        family = binomial(link = "logit"),
                        data = data)
summary(distr)
distr <- glmer(distr_yes_prompt ~ stress_w*IBES_gmc + stress_b*IBES_gmc + (1 | PID), 
                        family = binomial(link = "logit"),
                        data = data)

summary(distr)
min <- glmer(min_yes ~ stress_w*IBES_gmc + stress_b*IBES_gmc + (1 | PID), 
                        family = binomial(link = "logit"),
                        data = data)
summary(min)
min <- glmer(min_yes_prompt ~ stress_w*IBES_gmc + stress_b*IBES_gmc +(1 | PID), 
                        family = binomial(link = "logit"),
                        data = data)
summary(min)
reap <- glmer(reap_yes ~ stress_w*IBES_gmc + stress_b*IBES_gmc + (1 | PID), 
                        family = binomial(link = "logit"),
                        data = data)

summary(reap)
reap <- glmer(reap_yes_prompt ~ stress_w*IBES_gmc + stress_b*IBES_gmc +(1 | PID), 
                        family = binomial(link = "logit"),
                        data = data)

summary(reap)
#NIHCB
distr <- glmer(distr_yes ~ stress_w*NIHCB_gmc + stress_b*NIHCB_gmc + (1 | PID), 
                        family = binomial(link = "logit"),
                        data = data)
summary(distr)
#weaken, both within and between
ef <- effects::effect(term="stress_w:NIHCB_gmc", xlevels= list(NIHCB_gmc=c(-15.87, 15.87)), mod=distr)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$NIHCB_gmc<-as.factor(efdata$NIHCB_gmc)
g5<-ggplot(efdata, aes(x=stress_w, y=fit, color=NIHCB_gmc,group=NIHCB_gmc)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=NIHCB_gmc),alpha=0.3) + 
    labs(x= "stress_w", y="Distraction Use", color="NIHCB_gmc", fill="NIHCB_gmc") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.2, by=0.05), limits=c(0, 0.2)) +
    scale_x_continuous(breaks = seq(-5.5, 6, by=2), limits=c(-5.5, 6))
ef <- effects::effect(term="NIHCB_gmc:stress_b", xlevels= list(NIHCB_gmc=c(-15.87, 15.87)), mod=distr)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$NIHCB_gmc<-as.factor(efdata$NIHCB_gmc)
g6<-ggplot(efdata, aes(x=stress_b, y=fit, color=NIHCB_gmc,group=NIHCB_gmc)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=NIHCB_gmc),alpha=0.3) + 
    labs(x= "stress_b", y="Distraction Use", color="NIHCB_gmc", fill="NIHCB_gmc") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.8, by=0.2), limits=c(0, 0.8)) +
    scale_x_continuous(breaks = seq(-1.5, 4, by=1), limits=c(-1.5, 4))

distr <- glmer(distr_yes_prompt ~ stress_w*NIHCB_gmc + stress_b*NIHCB_gmc + (1 | PID), 
                        family = binomial(link = "logit"),
                        data = data)
summary(distr)
#N.S.

min <- glmer(min_yes ~ stress_w*NIHCB_gmc + stress_b*NIHCB_gmc +(1 | PID), 
                        family = binomial(link = "logit"),
                        data = data)
summary(min)
#weaken, between
ef <- effects::effect(term="NIHCB_gmc:stress_b", xlevels= list(NIHCB_gmc=c(-15.87, 15.87)), mod=min)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$NIHCB_gmc<-as.factor(efdata$NIHCB_gmc)
g7<-ggplot(efdata, aes(x=stress_b, y=fit, color=NIHCB_gmc,group=NIHCB_gmc)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=NIHCB_gmc),alpha=0.3) + 
    labs(x= "stress_b", y="Minimizing Use", color="NIHCB_gmc", fill="NIHCB_gmc") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.8, by=0.2), limits=c(0, 0.8)) +
    scale_x_continuous(breaks = seq(-1.5, 4, by=1), limits=c(-1.5, 4))

min <- glmer(min_yes_prompt ~ stress_w*NIHCB_gmc + stress_b*NIHCB_gmc +(1 | PID), 
                        family = binomial(link = "logit"),
                        data = data,
             control = glmerControl(optimizer = "bobyqa"))
summary(min)
#strengthen, within (p=0.09)
ef <- effects::effect(term="stress_w:NIHCB_gmc", xlevels= list(NIHCB_gmc=c(-15.87, 15.87)), mod=min)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$NIHCB_gmc<-as.factor(efdata$NIHCB_gmc)
g8<-ggplot(efdata, aes(x=stress_w, y=fit, color=NIHCB_gmc,group=NIHCB_gmc)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=NIHCB_gmc),alpha=0.3) + 
    labs(x= "stress_w", y="Mimimizing Use, prompt", color="NIHCB_gmc", fill="NIHCB_gmc") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.05, by=0.01), limits=c(0, 0.05)) +
    scale_x_continuous(breaks = seq(-5.5, 6, by=2), limits=c(-5.5, 6))

reap <- glmer(reap_yes ~ stress_w*NIHCB_gmc + stress_b*NIHCB_gmc + (1 | PID), 
                        family = binomial(link = "logit"),
                        data = data)
summary(reap)
#weaken, both within and between
ef <- effects::effect(term="stress_w:NIHCB_gmc", xlevels= list(NIHCB_gmc=c(-15.87, 15.87)), mod=reap)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$NIHCB_gmc<-as.factor(efdata$NIHCB_gmc)
g9<-ggplot(efdata, aes(x=stress_w, y=fit, color=NIHCB_gmc,group=NIHCB_gmc)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=NIHCB_gmc),alpha=0.3) + 
    labs(x= "stress_w", y="Reappraisal Use", color="NIHCB_gmc", fill="NIHCB_gmc") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.2, by=0.05), limits=c(0, 0.2)) +
    scale_x_continuous(breaks = seq(-5.5, 6, by=2), limits=c(-5.5, 6))
ef <- effects::effect(term="NIHCB_gmc:stress_b", xlevels= list(NIHCB_gmc=c(-15.87, 15.87)), mod=reap)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$NIHCB_gmc<-as.factor(efdata$NIHCB_gmc)
g10<-ggplot(efdata, aes(x=stress_b, y=fit, color=NIHCB_gmc,group=NIHCB_gmc)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=NIHCB_gmc),alpha=0.3) + 
    labs(x= "stress_b", y="Reappraisal Use", color="NIHCB_gmc", fill="NIHCB_gmc") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.8, by=0.2), limits=c(0, 0.8)) +
    scale_x_continuous(breaks = seq(-1.5, 4, by=1), limits=c(-1.5, 4))

reap <- glmer(reap_yes_prompt ~ stress_w*NIHCB_gmc + stress_b*NIHCB_gmc + (1 | PID), 
                        family = binomial(link = "logit"),
                        data = data)
summary(reap)
#weaken, between, p=0.06
ef <- effects::effect(term="NIHCB_gmc:stress_b", xlevels= list(NIHCB_gmc=c(-15.87, 15.87)), mod=reap)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$NIHCB_gmc<-as.factor(efdata$NIHCB_gmc)
g11<-ggplot(efdata, aes(x=stress_b, y=fit, color=NIHCB_gmc,group=NIHCB_gmc)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=NIHCB_gmc),alpha=0.3) + 
    labs(x= "stress_b", y="Reappraisal Use, prompt", color="NIHCB_gmc", fill="NIHCB_gmc") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.3, by=0.05), limits=c(-0.04, 0.3)) +
    scale_x_continuous(breaks = seq(-1.5, 4, by=1), limits=c(-1.5, 4))

#Group
distr <- glmer(distr_yes ~ stress_w*Group + stress_b*Group + (1 | PID), 
                        family = binomial(link = "logit"),
                        data = data,
              control = glmerControl(optimizer = "bobyqa"))
summary(distr)
ef <- effects::effect(term="stress_w:Group", mod=distr)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$Group<-as.factor(efdata$Group)
g12<-ggplot(efdata, aes(x=stress_w, y=fit, color=Group,group=Group)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=Group),alpha=0.3) + 
    labs(x= "stress_w", y="Distraction Use", color="Group", fill="Group") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.2, by=0.05), limits=c(0,0.2)) +
    scale_x_continuous(breaks = seq(-5.5, 6, by=2), limits=c(-5.5, 6))
ef <- effects::effect(term="Group:stress_b", mod=distr)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$Group<-as.factor(efdata$Group)
g13<-ggplot(efdata, aes(x=stress_b, y=fit, color=Group,group=Group)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=Group),alpha=0.3) + 
    labs(x= "stress_b", y="Distraction Use", color="Group", fill="Group") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.9, by=0.2), limits=c(0,0.9)) +
    scale_x_continuous(breaks = seq(-1.5, 4, by=1), limits=c(-1.5, 4))

distr <- glmer(distr_yes_prompt ~ stress_w*Group + stress_b*Group + (1 | PID),
                        family = binomial(link = "logit"),
                        data = data,
              control = glmerControl(optimizer = "bobyqa"))
summary(distr)
ef <- effects::effect(term="Group:stress_b", mod=distr)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$Group<-as.factor(efdata$Group)
g14<-ggplot(efdata, aes(x=stress_b, y=fit, color=Group,group=Group)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=Group),alpha=0.3) + 
    labs(x= "stress_b", y="Distraction Use, prompt", color="Group", fill="Group") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.5, by=0.1), limits=c(-0.02,0.5)) +
    scale_x_continuous(breaks = seq(-1.5, 4, by=1), limits=c(-1.5, 4))

min <- glmer(min_yes ~ stress_w*Group + stress_b*Group + (1 + stress_w | PID),
                        family = binomial(link = "logit"),
                        data = data,
              control = glmerControl(optimizer = "bobyqa"))
summary(min)
ef <- effects::effect(term="stress_w:Group", mod=min)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$Group<-as.factor(efdata$Group)
g15<-ggplot(efdata, aes(x=stress_w, y=fit, color=Group,group=Group)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=Group),alpha=0.3) + 
    labs(x= "stress_w", y="Minimizing Use", color="Group", fill="Group") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.25, by=0.05), limits=c(0,0.25)) +
    scale_x_continuous(breaks = seq(-5.5, 6, by=2), limits=c(-5.5, 6))
ef <- effects::effect(term="Group:stress_b", mod=min)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$Group<-as.factor(efdata$Group)
g16<-ggplot(efdata, aes(x=stress_b, y=fit, color=Group,group=Group)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=Group),alpha=0.3) + 
    labs(x= "stress_b", y="Minimizing Use", color="Group", fill="Group") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.6, by=0.1), limits=c(-0.02,0.6)) +
    scale_x_continuous(breaks = seq(-1.5, 4, by=1), limits=c(-1.5, 4))

min <- glmer(min_yes_prompt ~ stress_w*Group + stress_b*Group + (1 | PID),
                        family = binomial(link = "logit"),
                        data = data,
              control = glmerControl(optimizer = "bobyqa"))
summary(min)
ef <- effects::effect(term="Group:stress_b", mod=min)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$Group<-as.factor(efdata$Group)
g17<-ggplot(efdata, aes(x=stress_b, y=fit, color=Group,group=Group)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=Group),alpha=0.3) + 
    labs(x= "stress_b", y="Minimizing Use, Prompt", color="Group", fill="Group") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.4, by=0.1), limits=c(-0.02,0.4)) +
    scale_x_continuous(breaks = seq(-1.5, 4, by=1), limits=c(-1.5, 4))

reap <- glmer(reap_yes ~ stress_w*Group + stress_b*Group + (1 | PID), 
                        family = binomial(link = "logit"),
                        data = data,
              control = glmerControl(optimizer = "bobyqa"))
summary(reap)
ef <- effects::effect(term="stress_w:Group", mod=reap)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$Group<-as.factor(efdata$Group)
g18<-ggplot(efdata, aes(x=stress_w, y=fit, color=Group,group=Group)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=Group),alpha=0.3) + 
    labs(x= "stress_w", y="Reappraisal Use", color="Group", fill="Group") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.25, by=0.05), limits=c(0,0.25)) +
    scale_x_continuous(breaks = seq(-5.5, 6, by=2), limits=c(-5.5, 6))
ef <- effects::effect(term="Group:stress_b", mod=reap)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$Group<-as.factor(efdata$Group)
g19<-ggplot(efdata, aes(x=stress_b, y=fit, color=Group,group=Group)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=Group),alpha=0.3) + 
    labs(x= "stress_b", y="Reappraisal Use", color="Group", fill="Group") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.8, by=0.1), limits=c(-0.02,0.8)) +
    scale_x_continuous(breaks = seq(-1.5, 4, by=1), limits=c(-1.5, 4))

reap <- glmer(reap_yes_prompt ~ stress_w*Group + stress_b*Group + (1 | PID),
              family = binomial(link = "logit"),
              data = data,
              control = glmerControl(optimizer = "bobyqa"))
summary(reap)
ef <- effects::effect(term="stress_w:Group", mod=reap)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$Group<-as.factor(efdata$Group)
g20<-ggplot(efdata, aes(x=stress_w, y=fit, color=Group,group=Group)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=Group),alpha=0.3) + 
    labs(x= "stress_w", y="Reappraisal Use, Prompt", color="Group", fill="Group") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.05, by=0.01), limits=c(0,0.05)) +
    scale_x_continuous(breaks = seq(-5.5, 6, by=2), limits=c(-5.5, 6))
ef <- effects::effect(term="Group:stress_b", mod=reap)
efdata<-as.data.frame(ef) #convert the effects list to a data frame
efdata$Group<-as.factor(efdata$Group)
g21<-ggplot(efdata, aes(x=stress_b, y=fit, color=Group,group=Group)) + 
    geom_point() + 
    geom_line(size=1.2) +
    geom_ribbon(aes(ymin=fit-se, ymax=fit+se, fill=Group),alpha=0.3) + 
    labs(x= "stress_b", y="Reappraisal Use, Prompt", color="Group", fill="Group") +
    theme_classic() + theme(text=element_text(size=12)) + 
    scale_y_continuous(breaks = seq(0, 0.4, by=0.1), limits=c(-0.05,0.4)) +
    scale_x_continuous(breaks = seq(-1.5, 4, by=1), limits=c(-1.5, 4))
```

### Moderation Visualization
```{r mod graphs, echo=TRUE, eval=TRUE, fig.width=10, fig.height=8, warning=F, cache=TRUE, message=F}
grid.arrange(g1, g2, g3, g4,ncol=2)
grid.arrange(g5, g6, g7, g8, ncol=2) 
grid.arrange(g9, g10, g11,ncol=2) 
grid.arrange(g12, g13, g14, ncol=2)
 grid.arrange(g15, g16, g17, ncol=2)
grid.arrange(g18, g19, g20, g21, ncol=2)
```
